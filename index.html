<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>夜刀计算器</title>
    <style>
        body {
            font-family: "宋体", Arial, sans-serif;
            background-color: #e9ecef;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1000px;
            margin: auto;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        /* 两栏布局（左结果，右时间轴） */
        .two-col {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 520px;
            gap: 16px;
            align-items: start;
            margin-top: 16px;
        }
        @media (max-width: 1100px) {
            .two-col {
                grid-template-columns: 1fr;
            }
        }
        /* 统一面板样式 */
        .panel {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
            color: #343a40;
        }
        .panel-body {
            padding: 10px 12px;
        }
        .panel-scroll {
            max-height: 640px;
            overflow: auto;
        }
        /* 面板显示切换 */
        .hidden { display: none; }
        .two-col.single-col { grid-template-columns: 1fr; }
        .view-toggle { display:flex; gap:10px; justify-content:flex-end; margin-top: 8px; }
        /* 预格式文本统一样式 */
        pre {
            margin: 0;
            font-family: Consolas, "Courier New", monospace;
            font-size: 14px;
            white-space: pre;
            overflow: auto;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        #result {
            margin-top: 20px;
            font-size: 16px;
            white-space: pre-line;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .section-title {
            font-size: 20px;
            font-weight: bold;
            margin-top: 20px;
            color: #343a40;
        }
        h1 {
            text-align: center;
            color: #343a40;
            margin-bottom: 20px;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        .horizontal-label {
            display: inline-block;
            writing-mode: horizontal-tb;
            transform: rotate(0deg);
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center;">夜刀计算器</h1>
        <form id="calculator-form">
            <div class="section-title">参数输入：带有%的为百分比</div>
            <div class="form-group" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <label for="out_attack">局外加攻%</label>
                    <input type="number" id="out_attack" name="out_attack" value="0">
                </div>
                <div>
                    <label for="in_attack_mul">局内加攻%（乘算）</label>
                    <input type="number" id="in_attack_mul" name="in_attack_mul" value="0">
                </div>
                <div>
                    <label for="in_attack_add">局内加攻（加算）</label>
                    <input type="number" id="in_attack_add" name="in_attack_add" value="0">
                </div>
            </div>
            <div class="form-group" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <label for="phy_vuln">物理易伤%</label>
                    <input type="number" id="phy_vuln" name="phy_vuln" value="0">
                </div>
                <div>
                    <label for="mag_vuln">法术易伤%</label>
                    <input type="number" id="mag_vuln" name="mag_vuln" value="0">
                </div>
                <div>
                    <label for="fragile">脆弱%</label>
                    <input type="number" id="fragile" name="fragile" value="0">
                </div>
            </div>
            <div class="form-group" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <label for="enemy_armor">敌方护甲</label>
                    <input type="number" id="enemy_armor" name="enemy_armor" value="0">
                </div>
                <div>
                    <label for="enemy_resist">敌方法抗</label>
                    <input type="number" id="enemy_resist" name="enemy_resist" value="0">
                </div>
                <div>
                    <label for="enemy_reduce">敌方减伤%</label>
                    <input type="number" id="enemy_reduce" name="enemy_reduce" value="0">
                </div>
            </div>
            <div class="form-group" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <label for="attack_speed">攻速</label>
                    <input type="number" id="attack_speed" name="attack_speed" value="0" step="any">
                </div>
                <div>
                    <label for="landing_attack_speed">落地攻速</label>
                    <input type="number" id="landing_attack_speed" name="landing_attack_speed" value="0" step="any">
                </div>
                <div>
                    <label for="redeploy_time">再部署时间</label>
                    <input type="number" id="redeploy_time" name="redeploy_time" value="0" step="any">
                </div>
            </div>
            <div class="form-group">
                <label for="skill">技能选择</label>
                <select id="skill" name="skill">
                    <option value="一技能">一技能</option>
                    <option value="二技能">二技能</option>
                    <option value="三技能">三技能</option>
                </select>
            </div>
            <div class="form-group" style="display: flex; align-items: center; justify-content: space-around; gap: 30px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="j1" name="elite_stage" value="精一" style="width: 20px; height: 20px;">
                    <label for="j1" style="margin: 0; line-height: 20px;">精一</label>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="gd" name="gd" style="width: 20px; height: 20px;">
                    <label for="gd" style="margin: 0;">戈渎</label>
                </div>
            </div>
            <button type="button" onclick="calculate()">计算</button>
        </form>
            <div class="view-toggle">
                <button type="button" onclick="setView('both')">并排</button>
                <button type="button" onclick="setView('left')">只看结果</button>
                <button type="button" onclick="setView('right')">只看时间轴</button>
            </div>
            <div class="two-col" id="two-col">
                <section class="panel" id="panel-left">
                    <div class="panel-title">结果与累计表</div>
                    <div id="result" class="panel-body"></div>
                </section>
                <section class="panel" id="panel-right">
                    <div class="panel-title">时间轴参考</div>
                    <div id="timeline" class="panel-body panel-scroll"></div>
                </section>
        </div>
    </div>
    <script>
    function calculate() {
            const out_attack = parseFloat(document.getElementById('out_attack').value) || 0;
            const in_attack_mul = parseFloat(document.getElementById('in_attack_mul').value) || 0;
            const in_attack_add = parseFloat(document.getElementById('in_attack_add').value) || 0;
            const phy_vuln = parseFloat(document.getElementById('phy_vuln').value) || 0;
            const mag_vuln = parseFloat(document.getElementById('mag_vuln').value) || 0;
            const fragile = parseFloat(document.getElementById('fragile').value) || 0;
            const enemy_armor = parseFloat(document.getElementById('enemy_armor').value) || 0;
            const enemy_resist = parseFloat(document.getElementById('enemy_resist').value) || 0;
            const enemy_reduce = parseFloat(document.getElementById('enemy_reduce').value) || 0;
            const attack_speed = parseFloat(document.getElementById('attack_speed').value) || 0;
            const redeploy_time = parseFloat(document.getElementById('redeploy_time').value) || 0;
            const landing_attack_speed = parseFloat(document.getElementById('landing_attack_speed').value) || 0;

            const is_j1 = document.getElementById('j1').checked;
            const skill_selected = document.getElementById('skill').value;
            const is_gd = document.getElementById('gd').checked;

            const base_attack = is_j1 ? 552 : 725;
            const attack = Math.round(base_attack * (1 + out_attack / 100));
            let actual_in_attack = is_j1 ? in_attack_mul : (in_attack_mul + 23);
            let skill_attack = attack * (1 + actual_in_attack / 100) + in_attack_add;

            if (skill_selected === "二技能") {
                skill_attack *= is_j1 ? 1.3 : 1.5;
            } else if (skill_selected === "三技能") {
                if (is_j1) {
                    document.getElementById('result').innerText = "技能攻击力: 输入错误\n物理伤害: 输入错误\n法术伤害: 输入错误\n单次总伤: 输入错误";
                    return;
                } else {
                    skill_attack *= 3;
                }
            }

            let magic_attack = skill_attack * (is_j1 ? 0.13 : 0.2);
            if (skill_selected === "二技能") {
                magic_attack *= is_j1 ? 2.1 : 2.5;
            }

            const resist_reduction = enemy_resist / 100;

            let physical_damage = Math.max(skill_attack - enemy_armor, skill_attack * 0.05) * (1 - enemy_reduce / 100) * (1 + fragile / 100) * (1 + phy_vuln / 100);
            let magic_damage = Math.max(magic_attack * (1 - resist_reduction), magic_attack * 0.05) * (1 - enemy_reduce / 100) * (1 + fragile / 100) * (1 + mag_vuln / 100);

            let single_hit_damage = physical_damage + magic_damage;

            const formatNumber = (num, length) => num.toString().padStart(length, ' ');

            let resultHTML = "";
            if (is_gd) {
                let cumulative_damage = 0;
                let result_text = `<pre>攻击力: ${attack}\n技能攻击力: ${skill_attack.toFixed(2)}\n物理伤害: ${physical_damage.toFixed(2)}\n法术伤害: ${magic_damage.toFixed(2)}\n单次总伤: ${single_hit_damage.toFixed(2)}\n\n攻击次数与累计伤害对照表（戈渎）\n` + "=".repeat(80) + "\n";
                for (let row = 0; row < 250; row++) {
                    let line_parts = [];
                    for (let col = 0; col < 4; col++) {
                        let hit_count = row * 4 + col + 1;
                        if (hit_count <= 1000) {
                            let current_armor = hit_count <= 15 ? enemy_armor + (2900 - (hit_count - 1) * 200) : enemy_armor;
                            physical_damage = Math.max(skill_attack - current_armor, skill_attack * 0.05) * (1 - enemy_reduce / 100) * (1 + fragile / 100) * (1 + phy_vuln / 100);
                            magic_damage = Math.max(magic_attack * (1 - resist_reduction), magic_attack * 0.05) * (1 - enemy_reduce / 100) * (1 + fragile / 100) * (1 + mag_vuln / 100);
                            single_hit_damage = physical_damage + magic_damage;
                            cumulative_damage += single_hit_damage;
                            let damage_text = hit_count % 16 === 0 ? `<span style='color: red;'>${formatNumber(cumulative_damage.toFixed(2), 12)}</span>` : formatNumber(cumulative_damage.toFixed(2), 12);
                            line_parts.push(`${formatNumber(hit_count, 3)}次: ${damage_text}`);
                        } else {
                            line_parts.push("                ");
                        }
                    }
                    result_text += line_parts.join("  |  ") + "\n";
                }
                result_text += "</pre>";
                resultHTML += result_text;
            } else {
                let cumulative_damage = 0;
                let result_text = `<pre>攻击力: ${attack}\n技能攻击力: ${skill_attack.toFixed(2)}\n物理伤害: ${physical_damage.toFixed(2)}\n法术伤害: ${magic_damage.toFixed(2)}\n单次总伤: ${single_hit_damage.toFixed(2)}\n\n攻击次数与累计伤害对照表（普通模式）\n` + "=".repeat(80) + "\n";
                for (let row = 0; row < 250; row++) {
                    let line_parts = [];
                    for (let col = 0; col < 4; col++) {
                        let hit_count = row * 4 + col + 1;
                        if (hit_count <= 1000) {
                            cumulative_damage += single_hit_damage;
                            let damage_text = hit_count % 16 === 0 ? `<span style='color: red;'>${formatNumber(cumulative_damage.toFixed(2), 12)}</span>` : formatNumber(cumulative_damage.toFixed(2), 12);
                            line_parts.push(`${formatNumber(hit_count, 3)}次: ${damage_text}`);
                        } else {
                            line_parts.push("                ");
                        }
                    }
                    result_text += line_parts.join("  |  ") + "\n";
                }
                result_text += "</pre>";
                resultHTML += result_text;
            }

            // 时间轴参考（右侧）
            let timelineText = [];
            if (skill_selected === "一技能") {
                // 周期：再部署 + 21 秒
                const cycle = (redeploy_time || 0) + 21.0;
                timelineText.push(`技能周期：${cycle.toFixed(2)} 秒`);

                // 计算一技能时间轴（21s=630帧窗口）
                const tl = computeSkill1Timeline(attack_speed, is_j1, landing_attack_speed, 630);
                if ('n' in tl) {
                    timelineText.push(`实际攻速 n = ${tl.n}`);
                    timelineText.push(`前摇 = ${tl.pre} 帧`);
                    timelineText.push(`攻击间隔(帧) = `);
                    timelineText.push(`${JSON.stringify(tl.cycle_intervals)}`);
                } else {
                    timelineText.push(`实际攻速 n(前9秒) = ${tl.n1}`);
                    timelineText.push(`实际攻速 n(后11秒) = ${tl.n2}`);
                    timelineText.push(`前摇 = ${tl.pre} 帧`);
                    timelineText.push(`攻击间隔(帧, 前9秒) = `);
                    timelineText.push(`${JSON.stringify(tl.cycle_intervals_pre)}`);
                    timelineText.push(`攻击间隔(帧, 后11秒) = `);
                    timelineText.push(`${JSON.stringify(tl.cycle_intervals_post)}`);
                }
                timelineText.push("-".repeat(20));
                // 仅显示偶数次（每对第二次），一行一个值，格式为 x秒y帧，并在首次 >=270 帧位置插入 9秒分界线
                let insertedSplit = false;
                for (let i = 1; i < tl.times.length; i += 2) {
                    const tframe = tl.times[i];
                    if (!insertedSplit && Math.abs(landing_attack_speed) > 0 && tframe >= 270) {
                        timelineText.push("———— 9秒 ————");
                        insertedSplit = true;
                    }
                    const sec = Math.floor(tframe / 30);
                    const rem = tframe % 30;
                    const hitNo = i + 1;
                    timelineText.push(`第${String(hitNo).padStart(2,'0')}次: ${sec}秒${rem}帧`);
                }

                // 多次技能（累计至1000次）：每次内部与第一次一致；只列偶数次，但序号为实际累计次数
                timelineText.push("");
                timelineText.push("—— 多次技能（累计至1000次）——");
                timelineText.push(`周期：${cycle.toFixed(2)} 秒；起点：1秒`);
                const perSkillHits = tl.times.length;
                if (perSkillHits === 0) {
                    timelineText.push("（无可用命中点）");
                } else {
                    let skillIndex = 1;
                    while ((skillIndex - 1) * perSkillHits < 1000) {
                        const startSec = 1.0 + (skillIndex - 1) * cycle;
                        timelineText.push(`—— 第${skillIndex}次技能（起点：${startSec.toFixed(2)}秒） ——`);
                        const baseOffsetFrames = Math.round(startSec * 30);
                        for (let j = 2; j <= perSkillHits; j += 2) {
                            const labelCount = (skillIndex - 1) * perSkillHits + j;
                            if (labelCount > 1000) break;
                            const tframe = tl.times[j - 1];
                            const totalFrames = baseOffsetFrames + tframe;
                            const sec = Math.floor(totalFrames / 30);
                            const rem = totalFrames % 30;
                            timelineText.push(`第${String(labelCount).padStart(4,'0')}次: ${sec}秒${rem}帧`);
                        }
                        if (skillIndex * perSkillHits < 1000) {
                            timelineText.push("—— 分页 ——\n");
                        }
                        skillIndex += 1;
                    }
                }
            } else if (skill_selected === "二技能") {
                const cycle = (redeploy_time || 0) + 4.0;
                timelineText.push(`技能周期：${cycle.toFixed(2)} 秒`);
            } else {
                // 三技能：逐帧覆盖与每格命中
                const { frameRanges, cellHits } = computeSkill3Timing();
                timelineText.push("三技能逐帧覆盖范围");
                for (const fr of frameRanges) {
                    const [f, low, high] = fr;
                    timelineText.push(`第${String(f).padStart(2,'0')}帧: [${low.toFixed(3)}, ${high.toFixed(3)}]`);
                }
                timelineText.push("------------------------");
                timelineText.push("三技能每格命中");
                const counts = [];
                for (let k = 0; k <= 5; k++) {
                    const hits = cellHits[k] || [];
                    counts.push(hits.length);
                    timelineText.push(`第${k}格（共${hits.length}次）:`);
                    if (!hits.length) {
                        timelineText.push("  无\n");
                    } else {
                        for (const f of hits) {
                            timelineText.push(`  第${String(f).padStart(2,'0')}帧`);
                        }
                        timelineText.push("");
                    }
                }
                if (counts.length) {
                    timelineText.push(`各格命中次数：${counts.join('/')}`);
                }
            }

            document.getElementById('result').innerHTML = resultHTML;
            document.getElementById('timeline').innerHTML = `<pre>${timelineText.join('\n')}</pre>`;
        }

        // 视图切换：both/left/right
        function setView(mode) {
            const container = document.getElementById('two-col');
            const left = document.getElementById('panel-left');
            const right = document.getElementById('panel-right');
            if (!container || !left || !right) return;
            if (mode === 'left') {
                left.classList.remove('hidden');
                right.classList.add('hidden');
                container.classList.add('single-col');
            } else if (mode === 'right') {
                left.classList.add('hidden');
                right.classList.remove('hidden');
                container.classList.add('single-col');
            } else { // both
                left.classList.remove('hidden');
                right.classList.remove('hidden');
                container.classList.remove('single-col');
            }
        }

        // JS版本的一技能时间轴（含9秒/11秒分段与封顶）
        function computeSkill1Timeline(rawAttackSpeed, isJ1, landingAS = 0, maxFrames = 600) {
            const base = isJ1 ? 170 : 200;
            let n2 = rawAttackSpeed + base; // 后11秒
            n2 = Math.min(600, Math.max(1, n2));
            let n1 = rawAttackSpeed + landingAS + base; // 前9秒
            n1 = Math.min(600, Math.max(1, n1));
            const B = [28, 26, 8, 18, 32];
            const useTwo = Math.abs(landingAS) > 0;
            const preN = useTwo ? n1 : n2;
            const pre = Math.ceil(Math.min(7, 1400 / preN));

            const times = [];
            let t = pre;
            if (t <= maxFrames) times.push(t);
            if (t <= maxFrames) times.push(t);
            let j = 0;
            while (true) {
                const nUse = (useTwo && t < 270) ? n1 : n2;
                const delta = Math.ceil(B[j % 5] * (100.0 / nUse));
                t = t + delta;
                if (t > maxFrames) break;
                times.push(t);
                if (t > maxFrames) break;
                times.push(t);
                j += 1;
            }
            const cycleIntervals = (n) => B.map(b => Math.ceil(b * (100.0 / n)));
            const result = { pre, times };
            if (useTwo) {
                result.n1 = n1; result.n2 = n2;
                result.cycle_intervals_pre = cycleIntervals(n1);
                result.cycle_intervals_post = cycleIntervals(n2);
            } else {
                result.n = n2;
                result.cycle_intervals = cycleIntervals(n2);
            }
            return result;
        }

        // JS版本的三技能时间表
        function computeSkill3Timing() {
            const FPS = 30.0;
            const v = 8.0;
            const A = FPS / v; // 3.75
            const R = 0.51 + 0.1; // 0.61
            const maxF = 18;
            const frameRanges = [];
            for (let f = 1; f <= maxF; f++) {
                const x = (v / FPS) * f;
                const low = x - R;
                const high = x + R;
                frameRanges.push([f, low, high]);
            }
            const cellHits = {};
            for (let k = 0; k <= 5; k++) {
                let fmin = Math.ceil(A * (k - R));
                let fmax = Math.floor(A * (k + R));
                fmin = Math.max(fmin, 1);
                fmax = Math.min(fmax, maxF);
                let hits = [];
                if (fmin <= fmax) {
                    for (let f = fmin; f <= fmax; f++) hits.push(f);
                }
                cellHits[k] = hits;
            }
            return { frameRanges, cellHits };
        }
    </script>
</body>
</html>
