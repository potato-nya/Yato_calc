<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>夜刀计算器</title>
    <style>
        body {
            font-family: "宋体", Arial, sans-serif;
            background-color: #e9ecef;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1000px;
            margin: auto;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        /* 两栏布局（左结果，右时间轴） */
        .two-col {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 520px;
            gap: 16px;
            align-items: start;
            margin-top: 16px;
        }
        @media (max-width: 1100px) {
            .two-col {
                grid-template-columns: 1fr;
            }
        }
        /* 统一面板样式 */
        .panel {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
            color: #343a40;
        }
        .panel-body {
            padding: 10px 12px;
        }
        .panel-scroll {
            max-height: 640px;
            overflow: auto;
        }
        /* 面板显示切换 */
        .hidden { display: none; }
        .two-col.single-col { grid-template-columns: 1fr; }
        .view-toggle { display:flex; gap:10px; justify-content:flex-end; margin-top: 8px; }
        /* 预格式文本统一样式 */
        pre {
            margin: 0;
            font-family: Consolas, "Courier New", monospace;
            font-size: 14px;
            white-space: pre;
            overflow: auto;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        #result {
            margin-top: 20px;
            font-size: 16px;
            white-space: pre-line;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .section-title {
            font-size: 20px;
            font-weight: bold;
            margin-top: 20px;
            color: #343a40;
        }
        h1 {
            text-align: center;
            color: #343a40;
            margin-bottom: 20px;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        .horizontal-label {
            display: inline-block;
            writing-mode: horizontal-tb;
            transform: rotate(0deg);
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center;">夜刀计算器</h1>
        <form id="calculator-form">
            <div class="section-title">参数输入：带有%的为百分比</div>
            <div class="form-group" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <label for="out_attack">局外加攻%</label>
                    <input type="number" id="out_attack" name="out_attack" value="0">
                </div>
                <div>
                    <label for="in_attack_mul">局内加攻%（乘算）</label>
                    <input type="number" id="in_attack_mul" name="in_attack_mul" value="0">
                </div>
                <div>
                    <label for="in_attack_add">局内加攻（加算）</label>
                    <input type="number" id="in_attack_add" name="in_attack_add" value="0">
                </div>
            </div>
            <div class="form-group" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <label for="phy_vuln">物理易伤%</label>
                    <input type="number" id="phy_vuln" name="phy_vuln" value="0">
                </div>
                <div>
                    <label for="mag_vuln">法术易伤%</label>
                    <input type="number" id="mag_vuln" name="mag_vuln" value="0">
                </div>
                <div>
                    <label for="fragile">脆弱%</label>
                    <input type="number" id="fragile" name="fragile" value="0">
                </div>
            </div>
            <div class="form-group" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <label for="enemy_armor">敌方护甲</label>
                    <input type="number" id="enemy_armor" name="enemy_armor" value="0">
                </div>
                <div>
                    <label for="enemy_resist">敌方法抗</label>
                    <input type="number" id="enemy_resist" name="enemy_resist" value="0">
                </div>
                <div>
                    <label for="enemy_reduce">敌方减伤%</label>
                    <input type="number" id="enemy_reduce" name="enemy_reduce" value="0">
                </div>
            </div>
            <div class="form-group" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <label for="attack_speed">攻速</label>
                    <input type="number" id="attack_speed" name="attack_speed" value="0" step="any">
                </div>
                <div>
                    <label for="landing_attack_speed">落地攻速</label>
                    <input type="number" id="landing_attack_speed" name="landing_attack_speed" value="0" step="any">
                </div>
                <div>
                    <label for="redeploy_time">再部署时间</label>
                    <input type="number" id="redeploy_time" name="redeploy_time" value="0" step="any">
                </div>
            </div>
            <div class="form-group">
                <label for="skill">技能选择</label>
                <select id="skill" name="skill">
                    <option value="一技能">一技能</option>
                    <option value="二技能">二技能</option>
                    <option value="三技能">三技能</option>
                </select>
            </div>
            <div class="form-group" style="display: flex; align-items: center; justify-content: space-around; gap: 30px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="j1" name="elite_stage" value="精一" style="width: 20px; height: 20px;">
                    <label for="j1" style="margin: 0; line-height: 20px;">精一</label>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="gd" name="gd" style="width: 20px; height: 20px;">
                    <label for="gd" style="margin: 0;">戈渎</label>
                </div>
            </div>
            <button type="button" onclick="calculate()">计算</button>
        </form>
            <div class="view-toggle">
                <button type="button" onclick="setView('both')">并排</button>
                <button type="button" onclick="setView('left')">只看结果</button>
                <button type="button" onclick="setView('right')">只看时间轴</button>
            </div>
            <div class="two-col" id="two-col">
                <section class="panel" id="panel-left">
                    <div class="panel-title">结果与累计表</div>
                    <div id="result" class="panel-body"></div>
                </section>
                <section class="panel" id="panel-right">
                    <div class="panel-title">时间轴参考</div>
                    <div id="timeline" class="panel-body panel-scroll"></div>
                </section>
        </div>
    </div>
    <script>
    function calculate() {
            const out_attack = parseFloat(document.getElementById('out_attack').value) || 0;
            const in_attack_mul = parseFloat(document.getElementById('in_attack_mul').value) || 0;
            const in_attack_add = parseFloat(document.getElementById('in_attack_add').value) || 0;
            const phy_vuln = parseFloat(document.getElementById('phy_vuln').value) || 0;
            const mag_vuln = parseFloat(document.getElementById('mag_vuln').value) || 0;
            const fragile = parseFloat(document.getElementById('fragile').value) || 0;
            const enemy_armor = parseFloat(document.getElementById('enemy_armor').value) || 0;
            const enemy_resist = parseFloat(document.getElementById('enemy_resist').value) || 0;
            const enemy_reduce = parseFloat(document.getElementById('enemy_reduce').value) || 0;
            const attack_speed = parseFloat(document.getElementById('attack_speed').value) || 0;
            const redeploy_time = parseFloat(document.getElementById('redeploy_time').value) || 0;
            const landing_attack_speed = parseFloat(document.getElementById('landing_attack_speed').value) || 0;

            const is_j1 = document.getElementById('j1').checked;
            const skill_selected = document.getElementById('skill').value;
            const is_gd = document.getElementById('gd').checked;

            const base_attack = is_j1 ? 552 : 725;
            const attack = Math.round(base_attack * (1 + out_attack / 100));
            let actual_in_attack = is_j1 ? in_attack_mul : (in_attack_mul + 23);
            let skill_attack = attack * (1 + actual_in_attack / 100) + in_attack_add;

            if (skill_selected === "二技能") {
                skill_attack *= is_j1 ? 1.3 : 1.5;
            } else if (skill_selected === "三技能") {
                if (is_j1) {
                    document.getElementById('result').innerText = "技能攻击力: 输入错误\n物理伤害: 输入错误\n法术伤害: 输入错误\n单次总伤: 输入错误";
                    return;
                } else {
                    skill_attack *= 3;
                }
            }

            let magic_attack = skill_attack * (is_j1 ? 0.13 : 0.2);
            if (skill_selected === "二技能") {
                magic_attack *= is_j1 ? 2.1 : 2.5;
            }

            const resist_reduction = enemy_resist / 100;

            let physical_damage = Math.max(skill_attack - enemy_armor, skill_attack * 0.05) * (1 - enemy_reduce / 100) * (1 + fragile / 100) * (1 + phy_vuln / 100);
            let magic_damage = Math.max(magic_attack * (1 - resist_reduction), magic_attack * 0.05) * (1 - enemy_reduce / 100) * (1 + fragile / 100) * (1 + mag_vuln / 100);

            let single_hit_damage = physical_damage + magic_damage;

            const formatNumber = (num, length) => num.toString().padStart(length, ' ');

            let resultHTML = "";
            if (is_gd) {
                let cumulative_damage = 0;
                let result_text = `<pre>攻击力: ${attack}\n技能攻击力: ${skill_attack.toFixed(2)}\n物理伤害: ${physical_damage.toFixed(2)}\n法术伤害: ${magic_damage.toFixed(2)}\n单次总伤: ${single_hit_damage.toFixed(2)}\n\n攻击次数与累计伤害对照表（戈渎）\n` + "=".repeat(80) + "\n";
                for (let row = 0; row < 250; row++) {
                    let line_parts = [];
                    for (let col = 0; col < 4; col++) {
                        let hit_count = row * 4 + col + 1;
                        if (hit_count <= 1000) {
                            let current_armor = hit_count <= 15 ? enemy_armor + (2900 - (hit_count - 1) * 200) : enemy_armor;
                            physical_damage = Math.max(skill_attack - current_armor, skill_attack * 0.05) * (1 - enemy_reduce / 100) * (1 + fragile / 100) * (1 + phy_vuln / 100);
                            magic_damage = Math.max(magic_attack * (1 - resist_reduction), magic_attack * 0.05) * (1 - enemy_reduce / 100) * (1 + fragile / 100) * (1 + mag_vuln / 100);
                            single_hit_damage = physical_damage + magic_damage;
                            cumulative_damage += single_hit_damage;
                            let damage_text = hit_count % 16 === 0 ? `<span style='color: red;'>${formatNumber(cumulative_damage.toFixed(2), 12)}</span>` : formatNumber(cumulative_damage.toFixed(2), 12);
                            line_parts.push(`${formatNumber(hit_count, 3)}次: ${damage_text}`);
                        } else {
                            line_parts.push("                ");
                        }
                    }
                    result_text += line_parts.join("  |  ") + "\n";
                }
                result_text += "</pre>";
                resultHTML += result_text;
            } else {
                let cumulative_damage = 0;
                let result_text = `<pre>攻击力: ${attack}\n技能攻击力: ${skill_attack.toFixed(2)}\n物理伤害: ${physical_damage.toFixed(2)}\n法术伤害: ${magic_damage.toFixed(2)}\n单次总伤: ${single_hit_damage.toFixed(2)}\n\n攻击次数与累计伤害对照表（普通模式）\n` + "=".repeat(80) + "\n";
                for (let row = 0; row < 250; row++) {
                    let line_parts = [];
                    for (let col = 0; col < 4; col++) {
                        let hit_count = row * 4 + col + 1;
                        if (hit_count <= 1000) {
                            cumulative_damage += single_hit_damage;
                            let damage_text = hit_count % 16 === 0 ? `<span style='color: red;'>${formatNumber(cumulative_damage.toFixed(2), 12)}</span>` : formatNumber(cumulative_damage.toFixed(2), 12);
                            line_parts.push(`${formatNumber(hit_count, 3)}次: ${damage_text}`);
                        } else {
                            line_parts.push("                ");
                        }
                    }
                    result_text += line_parts.join("  |  ") + "\n";
                }
                result_text += "</pre>";
                resultHTML += result_text;
            }

            // 时间轴参考（右侧）
            let timelineText = [];
            // 分页标记点 ID 列表 (用于快捷翻页)
            let pageIds = []; 
            // 每次生成结果前，先清空之前的内容（如果需要的话，但这里是重新生成字符串）

            if (skill_selected === "一技能") {
                timelineText.push(`<span id="page-0" class="page-marker">提示：使用 PgUp/PgDn 或 [ / ] 键翻页</span>`);
                timelineText.push("=".repeat(40));
                pageIds.push("page-0");

                // 周期：再部署 + 21 秒
                const cycleSec = (redeploy_time || 0) + 21.0;
                timelineText.push(`技能周期：${cycleSec.toFixed(2)} 秒`);

                // 计算一技能时间轴（630帧窗口）
                const tl = computeSkill1Timeline(attack_speed, is_j1, landing_attack_speed, 630);
                if ('n' in tl) {
                    timelineText.push(`实际攻速 n = ${tl.n}`);
                    timelineText.push(`前摇 = ${tl.pre} 帧`);
                    timelineText.push(`攻击间隔(帧) = `);
                    timelineText.push(`${JSON.stringify(tl.cycle_intervals)}`);
                } else {
                    timelineText.push(`实际攻速 n(前9秒) = ${tl.n1}`);
                    timelineText.push(`实际攻速 n(后11秒) = ${tl.n2}`);
                    timelineText.push(`前摇 = ${tl.pre} 帧`);
                    timelineText.push(`攻击间隔(帧, 前9秒) = `);
                    timelineText.push(`${JSON.stringify(tl.cycle_intervals_pre)}`);
                    timelineText.push(`攻击间隔(帧, 后11秒) = `);
                    timelineText.push(`${JSON.stringify(tl.cycle_intervals_post)}`);
                }
                timelineText.push("-".repeat(20));
                
                // 单次技能轴显示
                let insertedSplit = false;
                for (let i = 1; i < tl.times.length; i += 2) {
                    const tframe = tl.times[i];
                    if (!insertedSplit && Math.abs(landing_attack_speed) > 0 && tframe >= 270) {
                        timelineText.push("———— 9秒 ————");
                        insertedSplit = true;
                    }
                    const sec = Math.floor(tframe / 30);
                    const rem = tframe % 30;
                    const hitNo = i + 1;
                    timelineText.push(`第${String(hitNo).padStart(2,'0')}次: ${sec}秒${rem}帧`);
                }

                // 多次技能（累计至1000次）
                timelineText.push("");
                timelineText.push("—— 多次技能（累计至1000次）——");
                timelineText.push(`周期：${cycleSec.toFixed(2)} 秒；\n每次技能起始偏移已含在单次轴(32帧)中`);
                
                const perSkillHits = tl.times.length;
                if (perSkillHits === 0) {
                    timelineText.push("（无可用命中点）");
                } else {
                    let skillIndex = 1;
                    while ((skillIndex - 1) * perSkillHits < 1000) {
                        const skillStartSec = (skillIndex - 1) * cycleSec;
                        
                        // 插入锚点
                        const pId = `page-${skillIndex}`;
                        pageIds.push(pId);
                        timelineText.push(`<span id="${pId}" class="page-marker">—— 第${skillIndex}次技能（基准起点：${skillStartSec.toFixed(2)}秒） ——</span>`);
                        
                        for (let j = 2; j <= perSkillHits; j += 2) {
                            const labelCount = (skillIndex - 1) * perSkillHits + j;
                            if (labelCount > 1000) break;
                            
                            const tframe = tl.times[j - 1]; // 相对帧 (含32帧起步)
                            const baseFrames = skillStartSec * 30;
                            const totalFrames = Math.round(baseFrames + tframe);
                            
                            const sec = Math.floor(totalFrames / 30);
                            const rem = totalFrames % 30;
                            timelineText.push(`第${String(labelCount).padStart(4,'0')}次: ${sec}秒${rem}帧`);
                        }
                        
                        if (skillIndex * perSkillHits < 1000) {
                            timelineText.push("—— 分页 ——\n");
                        }
                        skillIndex += 1;
                    }
                }
            } else if (skill_selected === "二技能") {
                const cycle = (redeploy_time || 0) + 4.0;
                timelineText.push(`技能周期：${cycle.toFixed(2)} 秒`);
                timelineText.push("=".repeat(35));
                timelineText.push("二技能出伤帧 (自部署起点)");
                timelineText.push("注:每段可能独立随机+1帧");
                timelineText.push("-".repeat(35));
                
                const baseFrames = [43, 63, 65, 73, 81, 89, 91, 97, 99, 110, 112, 114, 115, 117, 118, 120];
                baseFrames.forEach((f, i) => {
                    const sec = Math.floor(f / 30);
                    const rem = f % 30;
                    timelineText.push(`第${String(i+1).padStart(2,'0')}段: ${sec}秒${String(rem).padStart(2,'0')}帧`);
                });

            } else {
                // 三技能：逐帧覆盖与每格命中
                const { frameRanges, cellHits } = computeSkill3Timing();
                timelineText.push("三技能逐帧覆盖范围");
                for (const fr of frameRanges) {
                    const [f, low, high] = fr;
                    timelineText.push(`第${String(f).padStart(2,'0')}帧: [${low.toFixed(3)}, ${high.toFixed(3)}]`);
                }
                timelineText.push("------------------------");
                timelineText.push("三技能每格命中");
                const counts = [];
                for (let k = 0; k <= 5; k++) {
                    const hits = cellHits[k] || [];
                    counts.push(hits.length);
                    timelineText.push(`第${k}格（共${hits.length}次）:`);
                    if (!hits.length) {
                        timelineText.push("  无\n");
                    } else {
                        for (const f of hits) {
                            timelineText.push(`  第${String(f).padStart(2,'0')}帧`);
                        }
                        timelineText.push("");
                    }
                }
                if (counts.length) {
                    timelineText.push(`各格命中次数：${counts.join('/')}`);
                }
            }

            document.getElementById('result').innerHTML = resultHTML;
            const timelineDiv = document.getElementById('timeline');
            timelineDiv.innerHTML = `<pre>${timelineText.join('\n')}</pre>`;

            // 快捷翻页功能绑定 (仅一技能)
            if (skill_selected === "一技能" && pageIds.length > 0) {
                // 将页面索引存储在 timelineDiv 上，防止重复绑定导致状态错乱
                timelineDiv.dataset.pageIds = JSON.stringify(pageIds);
                timelineDiv.dataset.currPageIdx = "0";

                // 确保焦点以便接收键盘事件（如果需要的话，但通常我们绑定在document上）
                // 这里我们绑定在 document 上，但只在 timeline 面板可见时生效
                // 为了简单起见，我们定义一个全局处理函数，每次计算 update 
                
                // 移除旧的 listener (如果有)
                if (window._timelineKeyHandler) {
                    document.removeEventListener('keydown', window._timelineKeyHandler);
                }

                window._timelineKeyHandler = (e) => {
                    // 仅当时间轴可见时生效
                    if (document.getElementById('panel-right').classList.contains('hidden')) return;
                    
                    const pIds = JSON.parse(timelineDiv.dataset.pageIds || '[]');
                    let currIdx = parseInt(timelineDiv.dataset.currPageIdx || "0");
                    
                    let targetIdx = -1;
                    if (e.key === "PageDown" || e.key === "]") {
                        e.preventDefault();
                        targetIdx = currIdx + 1;
                    } else if (e.key === "PageUp" || e.key === "[") {
                        e.preventDefault();
                        targetIdx = currIdx - 1;
                    }

                    if (targetIdx >= 0 && targetIdx < pIds.length) {
                        const targetId = pIds[targetIdx];
                        const el = document.getElementById(targetId);
                        if (el) {
                            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            // 高亮一下?
                            timelineDiv.dataset.currPageIdx = targetIdx.toString();
                        }
                    }
                };
                document.addEventListener('keydown', window._timelineKeyHandler);
                
                // 自动跳到第一页
                setTimeout(() => {
                    const el = document.getElementById(pageIds[0]);
                    if (el) el.scrollIntoView({ behavior: 'auto', block: 'start' });
                }, 100);
            } else {
                // 非一技能，移除监听
                if (window._timelineKeyHandler) {
                    document.removeEventListener('keydown', window._timelineKeyHandler);
                    window._timelineKeyHandler = null;
                }
            }
        }

        // 视图切换：both/left/right
        function setView(mode) {
            const container = document.getElementById('two-col');
            const left = document.getElementById('panel-left');
            const right = document.getElementById('panel-right');
            if (!container || !left || !right) return;
            if (mode === 'left') {
                left.classList.remove('hidden');
                right.classList.add('hidden');
                container.classList.add('single-col');
            } else if (mode === 'right') {
                left.classList.add('hidden');
                right.classList.remove('hidden');
                container.classList.add('single-col');
            } else { // both
                left.classList.remove('hidden');
                right.classList.remove('hidden');
                container.classList.remove('single-col');
            }
        }

        // JS版本的一技能时间轴（含9秒/11秒分段与封顶）
        function computeSkill1Timeline(rawAttackSpeed, isJ1, landingAS = 0, maxFrames = 600) {
            const base = isJ1 ? 170 : 200;
            // 辅助四舍五入 (x.5 向上)
            const roundHalfUp = (n) => Math.floor(n + 0.5);

            let n2 = rawAttackSpeed + base;
            n2 = Math.min(600, Math.max(1, n2));
            
            let n1 = rawAttackSpeed + landingAS + base;
            n1 = Math.min(600, Math.max(1, n1));
            
            const useTwoPhase = Math.abs(landingAS) > 0.0;

            // 14帧段时长计算
            const calcDur14 = (currN) => {
                const f = 14 * 200 / currN;
                const r = roundHalfUp(f);
                const c = Math.ceil(f);
                if (r < c) return c + 1;
                return r;
            };

            // 简单14帧段时长 (用于4+2组合)
            const calcDur14Simple = (currN) => {
                const f = 14 * 200 / currN;
                return roundHalfUp(f);
            }

            // 初始时间：第32帧为动画第一帧，设为31
            let t = 31;
            const times = [];

            while (t <= maxFrames) {
                // 3个片段: Seg1(14), Seg2(14), Seg3(28 aka 14*2)
                for (let segIdx = 0; segIdx < 3; segIdx++) {
                    const currN = (useTwoPhase && t < 270) ? n1 : n2;

                    if (segIdx === 0 || segIdx === 1) {
                        // 14帧基准
                        const dur = calcDur14(currN);
                        // 出伤点: (dur+1)//2
                        const hitOffset = Math.floor((dur + 1) / 2);
                        const hitTime = t + hitOffset;
                        if (hitTime > maxFrames) break; 
                        times.push(hitTime); // 1st hit
                        times.push(hitTime); // 2nd hit
                        
                        t += dur;
                    } else {
                        // Seg3: 4+2 组合 (两个14帧基准段合成)
                        const dBase = calcDur14Simple(currN);
                        
                        // 3次出伤判定 (每次双连击)
                        const off1 = roundHalfUp(dBase * 6 / 14);
                        const off2 = roundHalfUp(dBase * 10 / 14);
                        const off3 = dBase + roundHalfUp(dBase * 5 / 14);
                        const offsets = [off1, off2, off3];

                        for (let off of offsets) {
                            const hitTime = t + off;
                            if (hitTime > maxFrames) break;
                            times.push(hitTime);
                            times.push(hitTime);
                        }

                        t += (2 * dBase);
                    }
                    if (t > maxFrames) break;
                }
                if (t > maxFrames) break;
            }

            // 为了UI显示“攻击间隔”，造一个示例列表
            const sampleN = useTwoPhase ? n1 : n2;
            const d1 = calcDur14(sampleN);
            const d2 = calcDur14(sampleN);
            const d3 = 2 * calcDur14Simple(sampleN);
            const intervalsDisplay = [d1, d2, d3];

            const result = { pre: 31, times: times };

            if (useTwoPhase) {
                const d1Post = calcDur14(n2);
                const d3Post = 2 * calcDur14Simple(n2);
                const intervalsPost = [d1Post, d1Post, d3Post];
                result.n1 = n1;
                result.n2 = n2;
                result.cycle_intervals_pre = intervalsDisplay;
                result.cycle_intervals_post = intervalsPost;
            } else {
                result.n = n2;
                result.cycle_intervals = intervalsDisplay;
            }
            
            return result;
        }

        // JS版本的三技能时间表
        function computeSkill3Timing() {
            const FPS = 30.0;
            const v = 8.0;
            const A = FPS / v; // 3.75
            const R = 0.51 + 0.1; // 0.61
            const maxF = 18;
            const frameRanges = [];
            for (let f = 1; f <= maxF; f++) {
                const x = (v / FPS) * f;
                const low = x - R;
                const high = x + R;
                frameRanges.push([f, low, high]);
            }
            const cellHits = {};
            for (let k = 0; k <= 5; k++) {
                let fmin = Math.ceil(A * (k - R));
                let fmax = Math.floor(A * (k + R));
                fmin = Math.max(fmin, 1);
                fmax = Math.min(fmax, maxF);
                let hits = [];
                if (fmin <= fmax) {
                    for (let f = fmin; f <= fmax; f++) hits.push(f);
                }
                cellHits[k] = hits;
            }
            return { frameRanges, cellHits };
        }
    </script>
</body>
</html>
